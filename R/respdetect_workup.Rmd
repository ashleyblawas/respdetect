---
title: "Respdetect workup"
author: "Ashley Blawas"
date: "07/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Import libraries
```{r, warning = FALSE, message = FALSE}
library(tidyverse)
library(R.matlab)
library(cowplot) # For subplotting
library(dbscan) # For dbscan clustering
library(segmented) # For piecewise linear regression
library(DescTools)
library(viridis) # For viridis color palette
library(vroom)
```

# Import data
## Import breath data output from Matlab 
```{r}
# Select a file ending in all_breath_data.mat
fname = file.choose()   

# Import data from this file
imported_data <- readMat(fname)

```

## Pull individual variables from imported data
```{r}
# Pull list of tags
taglist = unlist(imported_data$taglist)

# Pull duration of all dives
dive_start_s = imported_data$dive.start.s

# Pull duration of all surfacings
dive_end_s = imported_data$dive.end.s

# Pull index of each breath
breath_idx = imported_data$breath.idx

# Pull type of each breath
breath_type = imported_data$breath.type
for (i in 1:length(breath_type)){
  temp = unlist(breath_type[i])
  temp[temp==1] = "ss"
  temp[temp==2] = "log"
  breath_type[i] = list(temp)
}

# Pull logging intervals
log_ints = imported_data$logging.intervals.s

# Pull fs
fs = unlist(imported_data$fs)

# Pull depth 
p_full = imported_data$depth

# Remove imported data
rm(imported_data, fname, i, temp)
```

# Build useful dataframes
## Create dataframe with breath information
```{r}
# Initialize dataframe
breaths = data.frame()

# Go tag by tag
for (k in 1:length(taglist)) {
  tag = taglist[[k]]
  
  # Create time vectors
  p = as.vector(p_full[[k]][[1]])
  time_s = seq(0, ((1 / fs[k]) * length(p)), by = 1 / fs[k])
  
  # Get index of each breath relative to length of p
  breath_idx_tag = as.vector(breath_idx[[k]][[1]])
  
  # Get time in seconds of each breath
  breath_time_s = time_s[breath_idx_tag]
  
  # Calculate time in minutes and hours (mostly just for plotting)
  breath_time_m = breath_time_s / 60
  breath_time_h = breath_time_m / 60
  
  # Get the depth when the breath occured
  breath_depth = p[breath_idx_tag]
  
  # Save all of this information to a dataframe
  breaths_temp = data.frame(tag,
                            breath_time_s,
                            breath_time_m,
                            breath_time_h,
                            breath_depth)
  
  # Append to breath info from all tags
  breaths = rbind(breaths, breaths_temp)
}

# Remove temporary variables
rm(
  k,
  tag,
  p,
  time_s,
  breath_idx_tag,
  breath_time_s,
  breath_time_m,
  breath_time_h,
  breath_depth,
  breaths_temp, 
  breath_idx
)

```

# Acoustic validation
```{r}
var1 <- readline("Do you want to generate logging periods to audit for acoustic validation (y/n)?: "); var2 <-  readline("Do you want to validate your acoustic aduit against detected breaths (y/n)?: ")

```

## Randomly sample log intervals for acoustic auditing
```{r}
if (var1 == "y"){

log_times = data.frame()

# Go tag by tag
for (k in 1:length(taglist)) {
  if (length(unlist(log_ints[[k]]))>0) {
  tag = taglist[[k]]
  
  # Get the type of breath
  log_times_temp = log_ints[[k]]
  
  # Save all of this information to a dataframe
  logs_temp = data.frame(tag,
                         log_times_temp)
  
  # Append to breath info from all tags
  log_times = rbind(log_times, logs_temp)
  
  rm(logs_temp)
  }
}

names(log_times)[2] <- "log_start"
names(log_times)[3] <- "log_end"

log_times = log_times %>% mutate(log_dur = log_end-log_start)

total_log_time_s = sum(log_times$log_dur)
total_log_time_m = total_log_time_s/60
total_log_time_h = total_log_time_m/60

rm(tag, log_times_temp, logs_temp)

# Randomly pull rows and add their duration until you get to a total of 5% of total logging time
n = floor(0.10*total_log_time_s)
paste("The duration of logging periods to audit is:", n, "seconds")

total_sampled_dur = 0 
logs_to_audit = data.frame()

set.seed(2022)
while(total_sampled_dur <= n){
  sample_temp = sample_n(log_times, 1)
  if(dim(match_df(sample_temp, logs_to_audit))[1]==0){
    logs_to_audit = rbind(logs_to_audit, sample_temp)
    total_sampled_dur = total_sampled_dur + sample_temp$log_dur
  }
}
}
rm(var1)
```

## Import acoustic audits
```{r}
if (var2 == "y"){
  
list_of_files = list.files(path = "D:/gm/audit",
                            pattern = "acousticaud.txt$", 
                            full.names = TRUE)


# Read all the files and create a FileName column to store filenames
audited_breaths <- vroom(list_of_files, col_names = FALSE, id = "FileName")

names(audited_breaths)[2] <- "breath_start"
names(audited_breaths)[3] <- "breath_dur"
names(audited_breaths)[4] <- "comment"

audited_breaths = audited_breaths %>% mutate(tag = substr(FileName,13,21))

matched_breaths = data.frame()

for (i in unique(audited_breaths$tag)){
  breaths_tag = breaths %>% filter(tag == i)
  audited_breaths_tag = audited_breaths %>% filter(tag == i)
  for (j in audited_breaths_tag$breath_start){
  row_idx = which.min(abs(j-breaths_tag$breath_time_s))
  row_temp = data.frame(i, j, audited_breaths_tag$breath_dur[which(audited_breaths_tag$breath_start==j)], breaths_tag$breath_time_s[row_idx])
  matched_breaths = rbind(matched_breaths, row_temp)
  }
  
}
names(matched_breaths)[1] <- "tag"
names(matched_breaths)[2] <- "audited_breath_start"
names(matched_breaths)[3] <- "audited_breath_dur"
names(matched_breaths)[4] <- "detected_breath"


matched_breaths = matched_breaths %>% mutate(diff_start = audited_breath_start-detected_breath, diff_end = audited_breath_start+audited_breath_dur-detected_breath)

for (k in 1:dim(matched_breaths)[1]){
closest_point[k] = min(abs(matched_breaths$diff_start[k]), abs(matched_breaths$diff_end[k]))}

matched_breaths = matched_breaths%>% mutate(diff = ifelse(diff_start*diff_end<0, 0, closest_point)) 

ggplot() +  
  geom_point(data=matched_breaths, aes(x = seq(1, length(audited_breath_start)), y =diff, color = tag)) + 
  xlab('Index') + ylab('Difference between audited breath and detected breath (s)') + theme_bw() +
  xlim(-2, 131)

model <- lm(detected_breath~audited_breath_start, data=matched_breaths)
summary(model)
rm(var2)
}
```

# Continue building useful dataframes
## Create dataframes with dive and surfacing information
```{r}
# Initialize dataframes
dives = data.frame()
surfs = data.frame()

# Go tag by tag
for (k in 1:length(taglist)){
  tag = taglist[[k]]
  
  # Create time vectors
  p = as.vector(p_full[[k]][[1]])
  time_s = seq(0, ((1/fs[k])*length(p)), by = 1/fs[k])
  time_s = time_s[-length(time_s)] # Had to do this because timing was randomly acting up 

  # Get dive starts and ends and calculate dive duration
  dive_start_s_tag = dive_start_s[[k]][[1]]
  dive_end_s_tag = dive_end_s[[k]][[1]]
  dive_start_m = t(dive_start_s_tag/60)
  dive_end_m = t(dive_end_s_tag/60)
  dive_start_h = dive_start_m/60
  dive_end_h = dive_end_m/60
  
  dive_dur_s = t(dive_end_s_tag - dive_start_s_tag)
  dive_dur_m = dive_dur_s/60
  
  # Find indexes of dive starts/ends and max depth of each dive
  dive_start_idx = c()
  dive_end_idx = c()
  dive_depth = c()
  
  # Get index of start/end of dive relative to p
  for (i in 1:length(dive_start_s_tag)){
    dive_start_idx[i] = which(min(abs(dive_start_s_tag[i]-time_s)) == abs(dive_start_s_tag[i]-time_s))
    dive_end_idx[i] =   which(min(abs(dive_end_s_tag[i]-time_s)) == abs(dive_end_s_tag[i]-time_s))
    dive_depth[i] = max(p[dive_start_idx[i]:dive_end_idx[i]])
  }
  
  # Find depth at dive start/end
  dive_start_depth = p[dive_start_idx]
  dive_end_depth = p[dive_end_idx]
  
  # Save dive information in a dataframe
  dives_temp = data.frame(tag = tag, 
                     dive_start_s=t(dive_start_s_tag), dive_end_s=t(dive_end_s_tag),
                     dive_start_m = dive_start_m, dive_end_m  = dive_end_m, 
                     dive_start_h = dive_start_h, dive_end_h = dive_end_h, 
                     dive_start_idx = dive_start_idx, dive_end_idx = dive_end_idx, 
                     dive_dur_s = dive_dur_s, dive_dur_m = dive_dur_m, 
                     dive_start_depth = dive_start_depth, dive_end_depth = dive_end_depth, 
                     dive_depth = dive_depth)
  
  
  # Calculate surface duration as time between dives - remember dives here are defined by 5m threshold
  surf_dur_s = c()
  
  # First one is NaN because we don't know how long animal was at surface before the tag went on/after its last dive
  surf_dur_s[1] = NaN 
  # Last one is NaN because we don't know how long animal was at surface after tag came off/before its next dive
  surf_dur_s[length(dive_start_s_tag)+1] = NaN 
  
  # Surface durations in middle are difference between end and start of successive dives
  surf_dur_s[2:length(dive_start_s_tag)] = dive_start_s_tag[2:length(dive_start_s_tag)] - dive_end_s_tag[1:length(dive_start_s_tag)-1] 
  surf_dur_m = surf_dur_s/60
  
  # Calculate start and end of each surface interval
  surf_start_s = c(); surf_end_s = c()
  
  # First one/last one is NaN because we don't know how long animal was at surface before the tag went on/tag came off
  surf_start_s[1] = NaN
  surf_end_s[length(dive_start_s_tag)+1] = NaN
  
  # Surface starts/ends in middle are end and start of dives
  surf_start_s[2:(length(dive_start_s_tag)+1)] = dive_end_s_tag[1,]
  surf_end_s[1:length(dive_start_s_tag)] = dive_start_s_tag[1,]
  
  surf_start_m = surf_start_s/60
  surf_end_m = surf_end_s/60
  surf_start_h = surf_start_m/60
  surf_end_h = surf_end_m/60
  
  # Create vector that designates surface number
  surf_num = seq(1, length(surf_start_s), by = 1)
  
  # Create data frame with surface information
  surfs_temp =  data.frame(tag, surf_num = surf_num, surf_start_s = surf_start_s, surf_end_s = surf_end_s,
                      surf_start_m = surf_start_m, surf_end_m = surf_end_m,
                      surf_start_h = surf_start_h, surf_end_h = surf_end_h,
                      surf_dur_s = surf_dur_s, surf_dur_m = surf_dur_m);
  
  # Remove variables that are now in dive dataframe
  rm(dive_start_s_tag, dive_start_m, dive_start_h, dive_end_s_tag, dive_end_m, dive_end_h, dive_dur_s, dive_dur_m, dive_start_idx, dive_end_idx, dive_start_depth, dive_end_depth, dive_depth)
  
  # Remove variables that are now in surface dataframe
  rm(surf_start_s, surf_start_m, surf_start_h, surf_end_s, surf_end_m, surf_end_h, surf_dur_s, surf_dur_m, surf_num)
  
  dives = rbind(dives, dives_temp)
  surfs = rbind(surfs, surfs_temp)
  
  # Remove old dataframes and others
  rm(dives_temp, surfs_temp, i, tag, time_s, p)
  
  # Print out tag so can track progress
  print(taglist[[k]])
}

rm(k, dive_start_s, dive_end_s)
```

## Dive cluster analysis
```{r}
set.seed(420)  # Setting seed

# Create dataframe with dive depths and durations
dive_dur = data.frame(dive_depth = dives$dive_depth,
                      dive_dur_m = dives$dive_dur_m)

# Do dbscan clustering analysis
#dive_dur.dbscan_cl <-
  #dbscan::dbscan(dive_dur, eps = 5 , minPts = round(dim(dive_dur)[1] / 10, 0))


xx = cbind(dives$dive_dur_m, dives$dive_depth)

# hierarchical
clustering <- hclust(dist(xx,
                          method = "euclidian"),
                          method = "ward.D")

h.cl <- cutree(clustering, k=2)


# Add cluster to dives dataframe
dives = dives %>%
  mutate(cluster = h.cl)

# Remove variables that have been added to dataframe
#rm(dive_dur, dive_dur.dbscan_cl)
```

## Create dataframe with information about dives + pre-dive surfacings
```{r}
# Select surfaces that lead dives
temp_surfs_pre = surfs %>% filter(is.nan(surf_end_s) == FALSE)

# Combine dives and surfaces and remove first dive which we don't have full pre-dive surfacing for
pre_dive_surfs = na.omit(cbind(dives, temp_surfs_pre))

# Get rid of duplicated tag column
duplicated_names <- duplicated(colnames(pre_dive_surfs))
pre_dive_surfs = pre_dive_surfs[!duplicated_names]

rm(temp_surfs_pre, duplicated_names)
```

## Create dataframe with information about dives + post-dive surfacings
```{r}
# Select surfaces that lag dives
temp_surfs_post = surfs %>% filter(is.nan(surf_start_s) == FALSE)

# Combine dives and surfaces and remove last dive which we don't have full post-dive surfacing for
post_dive_surfs = na.omit(cbind(dives, temp_surfs_post))

# Get rid of duplicated tag column
duplicated_names <- duplicated(colnames(post_dive_surfs))
post_dive_surfs = post_dive_surfs[!duplicated_names]

rm(temp_surfs_post, duplicated_names)
```


# Plots to investigate dive/surface relationship
### Dive duration versus dive depth
```{r, echo = FALSE, fig.height = 3, fig.width = 6}
p1 = ggplot(data = dives, aes(y = dive_depth, x = dive_dur_m)) +
  geom_point(color = 'black', alpha = 0.5) +
  ylab('Dive Depth (m)') + xlab('Dive Duration (min)') +
  theme_bw()

p2 = ggplot(data = dives, aes(
  y = dive_depth,
  x = dive_dur_m,
  color = factor(cluster)
)) +
  scale_color_manual(values = c("darkblue", "red")) +
  geom_point(alpha = 0.5) +
  ylab('Dive Depth (m)') + xlab('Dive Duration (min)') +
  theme_bw() +
  theme(legend.position = "none")

plot_grid(
  p1,
  p2,
  ncol = 2,
  labels = c('A', 'B'),
  label_size = 12
)

rm(p1, p2)

# Print out summary stats of dive clusters
dives %>% group_by(cluster) %>% dplyr::summarize(
  n = n(),
  mean_dur = mean(dive_dur_m),
  median_dur = median(dive_dur_m),
  mean_depth = mean(dive_depth),
  median_depth = median(dive_depth)
)

```


### Dive duration versus surface duration preceeding dive and following dive for all dives
```{r, echo = FALSE, fig.height = 6, fig.width = 6}
# Edit psi_guess based on break point analysis (i.e. where does relationship between surface interval and dive duration change)
psi_guess = 2.5

# Plot dive duration vs. pre-dive surface duration for all dives
p1 = ggplot(data = pre_dive_surfs, aes(y = surf_dur_m, x = dive_dur_m)) +
  geom_point(aes(color = factor(cluster)), alpha = 0.5) +
  ylab('Pre-Dive Surface Duration (min)') + xlab('Dive Duration (min)') +
  theme_bw() + theme(legend.position = "none") +
  scale_color_manual(values = c("darkblue", "red"))

# Plot dive duration vs. post-dive surface duration for all dives
p2 = ggplot(data = post_dive_surfs, aes(y = surf_dur_m, x = dive_dur_m)) +
  geom_point(aes(color = factor(cluster)), alpha = 0.5) +
  ylab('Post-Dive Surface Duration (min)') + xlab('Dive Duration (min)') +
  theme_bw()+ theme(legend.position = "none") +
  scale_color_manual(values = c("darkblue", "red"))

# Segmented linear regression for pre-dive surfacings and dives
pre_dive_fit <- lm(surf_dur_m ~ dive_dur_m, data = pre_dive_surfs)
pre_dive_segmented.fit <-
  segmented(pre_dive_fit, seg.Z = ~ dive_dur_m, psi = psi_guess)
summary(pre_dive_segmented.fit)

# Create a data frame to hold prediction
pre_dive.segmented_pred <-
  data.frame(dive_dur_m = seq(
    from = min(pre_dive_surfs$dive_dur_m),
    to = max(pre_dive_surfs$dive_dur_m),
    by = 0.1
  ))

# Predict
pre_dive.segmented_pred$pred <-
  predict(pre_dive_segmented.fit, newdata = pre_dive.segmented_pred)

# Plot segmented linear regression results
p3 = ggplot(data = pre_dive_surfs, aes(y = surf_dur_m, x = dive_dur_m)) +
  geom_point(aes(color = factor(cluster)), alpha = 0.5) +
  scale_color_manual(values = c("darkblue", "red")) +
  geom_vline(xintercept = pre_dive_segmented.fit$psi[2],
             color = 'blue',
             linetype = "longdash") +
  geom_line(
    data = pre_dive.segmented_pred,
    aes(x = dive_dur_m, y = pred),
    color = 'red',
    size = 1
  ) +
  ylab('Pre-Dive Surface Duration (min)') + xlab('Dive Duration (min)') +
  theme_bw() + theme(legend.position = "none") 

# Segmented linear regression
post_dive_fit <- lm(surf_dur_m ~ dive_dur_m, data = post_dive_surfs)
post_dive_segmented.fit <-
  segmented(post_dive_fit, seg.Z = ~ dive_dur_m, psi = psi_guess)
summary(post_dive_segmented.fit)

# Create a data frame to hold prediction
post_dive.segmented_pred <-
  data.frame(dive_dur_m = seq(
    from = min(post_dive_surfs$dive_dur_m),
    to = max(post_dive_surfs$dive_dur_m),
    by = 0.1
  ))

# Predict
post_dive.segmented_pred$pred <-
  predict(post_dive_segmented.fit, newdata = post_dive.segmented_pred)

# Plot segmented linear regression results
p4 = ggplot(data = post_dive_surfs, aes(y = surf_dur_m, x = dive_dur_m)) +
  geom_point(aes(color = factor(cluster)), alpha = 0.5) +
  geom_vline(xintercept = post_dive_segmented.fit$psi[2],
             color = 'blue',
             linetype = "longdash") +
  geom_line(
    data = post_dive.segmented_pred,
    aes(x = dive_dur_m, y = pred),
    color = 'red',
    size = 1
  ) +
  ylab('Post-Dive Surface Duration (min)') + xlab('Dive Duration (min)') +
  theme_bw() + theme(legend.position = "none") +
  scale_color_manual(values = c("darkblue", "red"))

plot_grid(p1,
  p2,
  p3,
  p4,
  ncol = 2,
  labels = c('A', 'B', 'C', 'D'),
  label_size = 12
)


rm(
  pre_dive_fit,
  pre_dive_segmented.fit,
  pre_dive.segmented_pred,
  post_dive_fit,
  post_dive_segmented.fit,
  post_dive.segmented_pred
)

rm(p1, p2, p3, p4, psi_guess)
```




### Dive duration versus surface duration preceeding dive and following dive for deep/long dives
```{r, echo = FALSE, fig.height = 6, fig.width = 6}


# Filter dataframe to include only long dives
pre_dive_surfs_longdives = pre_dive_surfs %>% filter(cluster == 2)
post_dive_surfs_longdives = post_dive_surfs %>% filter(cluster == 2)

if (dim(pre_dive_surfs_longdives)[1]>0){
# Plot dive duration vs. pre-dive surface duration for all dives
p1 = ggplot(data = pre_dive_surfs_longdives, aes(y = surf_dur_m, x = dive_dur_m)) +
  geom_point(color = 'red', alpha = 0.5) +
  ylab('Pre-Dive Surface Duration (min)') + xlab('Dive Duration (min)') +
  theme_bw()

p3 = ggplot(data = pre_dive_surfs_longdives, aes(y = surf_dur_m, x = dive_dur_m)) +
  geom_point(color = 'red', alpha = 0.5) +
  geom_smooth(method = 'lm', color = 'black', linetype = 2)+
  ylab('Pre-Dive Surface Duration (min)') + xlab('Dive Duration (min)') +
  theme_bw()

fit_pre <- lm(surf_dur_m ~ dive_dur_m, data = pre_dive_surfs_longdives)
summary(fit_pre)

} else {
  p1 = NA
  p3 = NA
}

if (dim(post_dive_surfs_longdives)[1]>0){
# Plot dive duration vs. post-dive surface duration for all dives
p2 = ggplot(data = post_dive_surfs_longdives, aes(y = surf_dur_m, x = dive_dur_m)) +
  geom_point(color = 'red', alpha = 0.5) +
  ylab('Post-Dive Surface Duration (min)') + xlab('Dive Duration (min)') +
  theme_bw()

p4 = ggplot(data = post_dive_surfs_longdives, aes(y = surf_dur_m, x = dive_dur_m)) +
  geom_point(color = 'red', alpha = 0.5) +
  geom_smooth(method = 'lm', color = 'black', linetype = 2)+
  ylab('Post-Dive Surface Duration (min)') + xlab('Dive Duration (min)') +
  theme_bw()

fit_post <- lm(surf_dur_m ~ dive_dur_m, data = post_dive_surfs_longdives)
summary(fit_post)

} else {
  p2 = NA
  p4 = NA
}

plot_grid(
  p1,
  p2,
  p3,
  p4,
  ncol = 2,
  labels = c('A', 'B', 'c', 'D'),
  label_size = 12
)

rm(post_dive_surfs_longdives, pre_dive_surfs_longdives, fit_pre, fit_post)

rm(p1, p2, p3, p4)
```



# Match up breaths with surfacings
## Determine breaths during each surface interval
```{r}
# Print out number of breaths per tag
breaths %>% group_by(tag) %>% dplyr::summarize(breath_count = n())

# Initiate dataframe for storing breath information
breaths_by_surf = data.frame()

for (k in 1:length(taglist)) {
  # Inititate more lists for surfacing information within a single tag
  surf_breaths_tag = list()
  surf_breaths_time_s_tag = list()
  surf_fr_tag = list()
  surf_num_tag = list()
  surf_breath_idx = list()
  surf_breath_idx_r = list()
  surf_breath_tot = list()
  
  tag_name = taglist[[k]]
  
  # Filter surfacings to only look at those associated with this tag
  surfs_tag = na.omit(surfs) %>% filter(tag == tag_name)
  
  # Filter surfacings to only look at those associated with this tag
  breaths_tag = breaths %>% filter(tag == tag_name)
  
  for (j in 1:dim(surfs_tag)[1]) {
    # Find breaths that occur during each surface interval
    surf_breaths_tag[[j]] = breaths_tag$breath_time_s[which(
      between(
        breaths_tag$breath_time_s,
        surfs_tag$surf_start_s[j],
        surfs_tag$surf_end_s[j]
      ) == TRUE
    )]
    # Get the timing of each breath relative to first breath during the surface interval
    surf_breaths_time_s_tag[[j]] = surf_breaths_tag[[j]] - surf_breaths_tag[[j]][1]
    
    # Calculate breathing rate (breaths/min)
    if (length(surf_breaths_time_s_tag[[j]]) > 1) {
      surf_fr_tag[[j]] = 60 / diff(surf_breaths_tag[[j]])
    }
    else {
      surf_fr_tag[[j]] = NaN
    }
    
    # Store surface number
    surf_num_tag[[j]] = surfs_tag$surf_num[j]
    
    # Store total number of breaths
    surf_breath_tot[[j]] = length(surf_breaths_time_s_tag[[j]])
    
    # Store index of each breath
    surf_breath_idx[[j]] = seq(1, length(surf_fr_tag[[j]]), by = 1)
    
    # Store index of each breath in reverse direction
    surf_breath_idx_r[[j]] = seq(-1*length(surf_fr_tag[[j]]), -1, by = 1)
  }
  
  # Write info to dataframe
  temp_breaths = tibble(
    tag = tag_name,
    surf_num = surf_num_tag,
    surf_breath_tot = surf_breath_tot,
    breath_idx = surf_breaths_tag,
    breath_time_s = surf_breaths_time_s_tag,
    fr = surf_fr_tag,
    breath_surf_idx = surf_breath_idx,
    breath_surf_idx_r = surf_breath_idx_r
  )
  
  # Append current tag info to rest of tag info
  breaths_by_surf = rbind(breaths_by_surf, temp_breaths)
  
  # Remove variables stored in dataframe
  rm(
    surf_breaths_tag,
    surf_breaths_time_s_tag,
    surf_fr_tag,
    temp_breaths,
    surf_num_tag,
    surf_breath_idx, 
    surf_breath_idx_r,
    surf_breath_tot
  )
}

# Remove extra variables
rm(j, k, tag_name, surfs_tag, breaths_tag)

```

# Plots to look at breathing rate during surface intervals
### fR for all surface intervals
```{r, echo = FALSE ,fig.height = 6, fig.width= 6}
# Unlist fr and index information to plot
fr = unlist(breaths_by_surf$fr, recursive = FALSE)
index = unlist(breaths_by_surf$breath_surf_idx, recursive = FALSE)

# Make temporary dataframe to store these vectors and remove surfacings with only one breath (i.e. fR = NaN)
temp_fr = na.omit(data.frame(cbind(fr, index)))

# Summarize fR by breath index
temp_fr %>%
  group_by(index) %>%
  dplyr::summarize(mean_fr = mean(fr), median = median(fr))

# Calculate number of bins using Sturge's rule
n = 1 + 3.322*log(length(temp_fr$fr))

p1 = ggplot(temp_fr,  aes(x = fr)) +
  geom_histogram(aes(y = ..density..), colour = 1, fill = "gray", bins = n) +
  geom_density() +
  labs(
    x = expression(f[R]~(breaths/min)),
    y = "Density",
    title = bquote(paste('Density of f'['R']))
  ) +
  theme_bw()

p2 = ggplot(data = temp_fr, aes(x = index, y = fr))+
  geom_point(color = 'black', alpha = 0.1, size = 0.5)+
  ylab(expression(f[R]~(breaths/min))) + xlab('Breath # of surface interval') +
  ggtitle(bquote(paste('f'['R']*' during all surfacings'))) +
  theme_bw()

p3 = ggplot(data = temp_fr, aes(x = index, y = fr))+
  geom_jitter(color = 'black', alpha = 0.1, width =0.3, size =0.5)+
  ylab(expression(f[R]~(breaths/min))) + xlab('Breath # of surface interval') +
  ggtitle(bquote(paste('f'['R']*' for first 5 breaths of surfacing'))) +
  theme_bw() + xlim(0.5, 5.5)

top_row = plot_grid(p1, p3, labels = c('A', 'B'), rel_widths = c(1, 1), label_size = 12)

plot_grid(top_row, p2, labels = c('A', 'B'), ncol = 1, rel_widths = c(1,2.25), label_size = 12)

rm(temp_fr, fr, index, p1, p2, p3, top_row, n)

```



# Assigning breaths to surfacings and surfacings to pre and post dives
## Match up breaths/surfacings with dives
```{r}
# Merge breaths_by_surf with pre_dive_surfs and post_dive_surfs
pre_dive_breaths_by_surf = merge(pre_dive_surfs, breaths_by_surf)
post_dive_breaths_by_surf = merge(post_dive_surfs, breaths_by_surf)

rm(pre_dive_surfs, post_dive_surfs)
```

## Plot post dive breathing rates for long and short dives
```{r, echo = FALSE, fig.height = 3, fig.width = 6.5}
# Filter breath/surf/dive information to only look at deep dives
post_longdives_temp = post_dive_breaths_by_surf %>%
  filter(cluster == 2) %>%
  filter(surf_breath_tot>1)

fr_tots_long = unlist(post_longdives_temp$surf_breath_tot)-1

post_longdives_breaths = data.frame(breath_surf_idx= unlist(post_longdives_temp$breath_surf_idx), fr = unlist(post_longdives_temp$fr), dive_dur_m = rep(post_longdives_temp$dive_dur_m, fr_tots_long))


p1 = ggplot(data = post_longdives_breaths, aes(x = breath_surf_idx, y = fr, color = dive_dur_m))+
  geom_point(alpha = 0.5, size = 1)+
  ylab(expression(f[R]~(breaths/min))) + xlab('Breath # of surface interval') + ggtitle(bquote(paste('Post long dive '* 'f'['R'])))+
  theme_bw()+ theme(legend.position = "none") +
  scale_color_viridis(limits = c(0 , max(post_longdives_breaths$dive_dur_m)))

post_shortdives_temp = post_dive_breaths_by_surf %>%
  filter(cluster == 1) %>%
  filter(surf_breath_tot>1)

fr_tots_short = unlist(post_shortdives_temp$surf_breath_tot)-1

post_shortdives_breaths = data.frame(breath_surf_idx = unlist(post_shortdives_temp$breath_surf_idx), fr = unlist(post_shortdives_temp$fr), dive_dur_m  = rep(post_shortdives_temp$dive_dur_m, fr_tots_short))

p2 = ggplot(data = post_shortdives_breaths, aes(x = breath_surf_idx, y = fr, color = dive_dur_m))+
  geom_point(alpha = 0.5, size = 1) + xlab('Breath # of surface interval') + ggtitle(bquote(paste('Post short dive '* 'f'['R'])))+
  theme_bw()+ theme(legend.position = "none") + ylab('')+
  theme_bw() +
 scale_color_viridis(limits = c(0 , max(post_shortdives_breaths$dive_dur_m)), name = "Dive Duration (min)")

plot_grid(p1, p2,  labels = c('A', 'B'), rel_widths = c(1,1.5), label_size = 12)

rm(p1, p2, fr_tots_short, fr_tots_long, post_longdives_temp, post_shortdives_temp, post_shortdives_breaths, post_longdives_breaths)

```

## Plot pre dive breathing rates for long and short dives
```{r, echo = FALSE, fig.height = 3, fig.width = 6.5}
# Filter breath/surf/dive information to only look at deep dives
pre_longdives_temp = pre_dive_breaths_by_surf %>%
  filter(cluster == 2) %>%
  filter(surf_breath_tot>1)

fr_tots_long = unlist(pre_longdives_temp$surf_breath_tot)-1

pre_longdives_breaths = data.frame(breath_surf_idx= unlist(pre_longdives_temp$breath_surf_idx_r), fr = unlist(pre_longdives_temp$fr), dive_dur_m = rep(pre_longdives_temp$dive_dur_m, fr_tots_long))


p1 = ggplot(data = pre_longdives_breaths, aes(x = breath_surf_idx, y = fr, color = dive_dur_m))+
  geom_point(alpha = 0.5, size = 1)+
  ylab(expression(f[R]~(breaths/min))) + xlab('Breath # of surface interval') + ggtitle(bquote(paste('Pre long dive '* 'f'['R'])))+
  theme_bw()+ theme(legend.position = "none") +
  scale_color_viridis(limits = c(0 , max(pre_longdives_breaths$dive_dur_m)))

pre_shortdives_temp = pre_dive_breaths_by_surf %>%
  filter(cluster == 1) %>%
  filter(surf_breath_tot>1)

fr_tots_short = unlist(pre_shortdives_temp$surf_breath_tot)-1

pre_shortdives_breaths = data.frame(breath_surf_idx = unlist(pre_shortdives_temp$breath_surf_idx_r), fr = unlist(pre_shortdives_temp$fr), dive_dur_m  = rep(pre_shortdives_temp$dive_dur_m, fr_tots_short))

p2 = ggplot(data = pre_shortdives_breaths, aes(x = breath_surf_idx, y = fr, color = dive_dur_m))+
  geom_point(alpha = 0.5, size = 1) + xlab('Breath # of surface interval')  + ggtitle(bquote(paste('Pre short dive '* 'f'['R'])))+  ylab('')+
  theme_bw() +
 scale_color_viridis(limits = c(0 , max(pre_shortdives_breaths$dive_dur_m)), name = "Dive Duration (min)")

plot_grid(p1, p2,  labels = c('A', 'B'), rel_widths = c(1,1.5), label_size = 12)

rm(p1, p2, fr_tots_short, fr_tots_long, pre_longdives_temp, pre_shortdives_temp, pre_shortdives_breaths, pre_longdives_breaths)

```

## Calculate pre dive average breathing rates across relevant windows: 1, 3, 5 minutes
```{r, echo = FALSE, fig.height = 4, fig.width = 6}

cluster.colors <- c("1" = "darkblue", "2" = "red")

pre_1min_fr = vector()
pre_3min_fr = vector()
pre_5min_fr = vector()

#Need to find breath times that are 1 min or less after surfacing
for (j in 1:dim(pre_dive_breaths_by_surf)[1]) {
  if (max(pre_dive_breaths_by_surf$breath_idx[[j]]) > 60 + pre_dive_breaths_by_surf$surf_start_s[j]) {
    pre_1min_fr[j] = mean(pre_dive_breaths_by_surf$fr[[j]][1:sum(
      pre_dive_breaths_by_surf$breath_idx[[j]] < 60 + pre_dive_breaths_by_surf$surf_start_s[j])-1])
  }
  else{
    pre_1min_fr[j] = 0
  }
  
  if (max(pre_dive_breaths_by_surf$breath_idx[[j]]) > 180 + pre_dive_breaths_by_surf$surf_start_s[j]) {
    pre_3min_fr[j] = mean(pre_dive_breaths_by_surf$fr[[j]][1:sum(
      pre_dive_breaths_by_surf$breath_idx[[j]] < 180 + pre_dive_breaths_by_surf$surf_start_s[j]
    ) - 1])
  }
  else{
    pre_3min_fr[j] = 0
  }
  
  if (max(pre_dive_breaths_by_surf$breath_idx[[j]]) > 300 + pre_dive_breaths_by_surf$surf_start_s[j]) {
    pre_5min_fr[j] = mean(pre_dive_breaths_by_surf$fr[[j]][1:sum(
      pre_dive_breaths_by_surf$breath_idx[[j]] < 300 + pre_dive_breaths_by_surf$surf_start_s[j]
    ) - 1])
  }
  else{
    pre_5min_fr[j] = 0
  }
}

pre_dive_breaths_by_surf = pre_dive_breaths_by_surf %>% 
  mutate(pre_1min_fr, pre_3min_fr, pre_5min_fr)

pre_1min_fr_temp = pre_dive_breaths_by_surf %>% filter(pre_1min_fr>0)
pre_3min_fr_temp = pre_dive_breaths_by_surf %>% filter(pre_3min_fr>0)
pre_5min_fr_temp = pre_dive_breaths_by_surf %>% filter(pre_5min_fr>0)

p1 = ggplot(data = pre_1min_fr_temp, aes(y = pre_1min_fr, x = dive_dur_m, color = as.factor(cluster)))+
  geom_point(alpha = 0.5, size = 1, aes(color = factor(cluster)))+
  scale_color_manual(values = cluster.colors) +
  ylab(expression(Avg.~f[R]~(breaths/min))) + xlab("") +
  theme_bw()+ theme(legend.position = "none") 

p2 = ggplot(data = pre_3min_fr_temp, aes(y = pre_3min_fr, x = dive_dur_m, color = as.factor(cluster)))+
  geom_point(alpha = 0.5, size = 1, aes(color = factor(cluster)))+
  scale_color_manual(values = cluster.colors) +
  ylab(expression(Avg.~f[R]~(breaths/min))) + xlab("")  +
  theme_bw()+ theme(legend.position = "none")

p3 = ggplot(data = pre_5min_fr_temp, aes(y = pre_5min_fr, x = dive_dur_m, color = as.factor(cluster)))+
  geom_point(alpha = 0.5, size = 1, aes(color = factor(cluster)))+
  scale_color_manual(values = cluster.colors) +
  ylab(expression(Avg.~f[R]~(breaths/min))) + xlab('Dive duration (min)') +
  theme_bw()+ theme(legend.position = c(20, 2))+ labs(colour = "Cluster")

plot_grid(p1, p2, p3, labels = c('A', 'B', 'C'), ncol =1, rel_widths = c(1, 1, 1), label_size = 12)

rm(p1, p2, p3)

rm(pre_1min_fr_temp, pre_3min_fr_temp, pre_5min_fr_temp, pre_1min_fr, pre_3min_fr, pre_5min_fr, j)

```

## Calculate post dive average breathing rates across relevant windows: 1, 3, 5 minutes
```{r, echo = FALSE, fig.height = 4, fig.width = 6}

cluster.colors <- c("1" = "darkblue", "2" = "red")

post_1min_fr = vector()
post_3min_fr = vector()
post_5min_fr = vector()

#Need to find breath times that are 1 min or less after surfacing
for (j in 1:dim(post_dive_breaths_by_surf)[1]) {
  if (max(post_dive_breaths_by_surf$breath_idx[[j]]) > 60 + post_dive_breaths_by_surf$surf_start_s[j]) {
    post_1min_fr[j] = mean(post_dive_breaths_by_surf$fr[[j]][1:sum(
      post_dive_breaths_by_surf$breath_idx[[j]] < 60 + post_dive_breaths_by_surf$surf_start_s[j])-1])
  }
  else{
    post_1min_fr[j] = 0
  }
  
  if (max(post_dive_breaths_by_surf$breath_idx[[j]]) > 180 + post_dive_breaths_by_surf$surf_start_s[j]) {
    post_3min_fr[j] = mean(post_dive_breaths_by_surf$fr[[j]][1:sum(
      post_dive_breaths_by_surf$breath_idx[[j]] < 180 + post_dive_breaths_by_surf$surf_start_s[j]
    ) - 1])
  }
  else{
    post_3min_fr[j] = 0
  }
  
  if (max(post_dive_breaths_by_surf$breath_idx[[j]]) > 300 + post_dive_breaths_by_surf$surf_start_s[j]) {
    post_5min_fr[j] = mean(post_dive_breaths_by_surf$fr[[j]][1:sum(
      post_dive_breaths_by_surf$breath_idx[[j]] < 300 + post_dive_breaths_by_surf$surf_start_s[j]
    ) - 1])
  }
  else{
    post_5min_fr[j] = 0
  }
}

post_dive_breaths_by_surf = post_dive_breaths_by_surf %>% 
  mutate(post_1min_fr, post_3min_fr, post_5min_fr)

post_1min_fr_temp = post_dive_breaths_by_surf %>% filter(post_1min_fr>0)
post_3min_fr_temp = post_dive_breaths_by_surf %>% filter(post_3min_fr>0)
post_5min_fr_temp = post_dive_breaths_by_surf %>% filter(post_5min_fr>0)

p1 = ggplot(data = post_1min_fr_temp, aes(y = post_1min_fr, x = dive_dur_m, color = as.factor(cluster)))+
  geom_point(alpha = 0.5, size = 1, aes(color = factor(cluster)))+
  scale_color_manual(values = cluster.colors) +
  ylab(expression(Avg.~f[R]~1~min.~(breaths/min))) + xlab("") +
  theme_bw()+ theme(legend.position = "none")

p2 = ggplot(data = post_3min_fr_temp, aes(y = post_3min_fr, x = dive_dur_m, color = as.factor(cluster)))+
  geom_point(alpha = 0.5, size = 1, aes(color = factor(cluster)))+
  scale_color_manual(values = cluster.colors) +
  ylab(expression(Avg.~f[R]~3~min.e~(breaths/min))) + xlab("")  +
  theme_bw()+ theme(legend.position = "none") 

p3 = ggplot(data = post_5min_fr_temp, aes(y = post_5min_fr, x = dive_dur_m, color = as.factor(cluster)))+
  geom_point(alpha = 0.5, size = 1, aes(color = factor(cluster)))+
  scale_color_manual(values = cluster.colors) +
  ylab(expression(Avg.~f[R]~5~min.~(breaths/min))) + xlab('Dive duration (min)') +
  theme_bw()+ theme(legend.position = c(20, 2))+ labs(colour = "Cluster")

plot_grid(p1, p2, p3, labels = c('A', 'B', 'C'), ncol =1, rel_widths = c(1, 1, 1), label_size = 12)

rm(p1, p2, p3)

rm(post_1min_fr_temp, post_3min_fr_temp, post_5min_fr_temp, post_1min_fr, post_3min_fr, post_5min_fr, j)

```

